![header](https://capsule-render.vercel.app/api?type=rect&color=gradient&customColorList=19&height=200&section=header&text=%EC%8B%A4%EC%8A%B5%EC%98%88%EC%A0%9C&fontSize=70&fontColor=ffffff)


## HW1: 변수, 할당, 복사, 컨텍스트, this

### 🔹 1-1
> 변수의 선언시 변수 영역에 식별자로 지정된 공간이 확보됨을 확인할 수 있다. 값 할당은 되지 않았으므로 undefined로 초기화됨.

### 🔹 1-2
> 데이터가 데이터영역에 할당되면 데이터는 변수 영역 값이 가리키고있는 주소에 저장됨을 확인할 수 있다. 두 과정을 한 줄로 표현할 수도 있음.

### 🔹 1-3
> 수, 문자열, boolean, Null, Undefined, Symbol은 불변(immutable). 변수 a에 문자열을 추가하면 새로운 문자열이 생성되고, a는 그 주소를 참조한다.

### 🔹 1-4
> 객체? 참조형 데이터. 참조형 데이터가 데이터 영역에 있다면 그 데이터가 가리키는 변수가 변함에 따라 그 값도 변화한다.

### 🔹 1-5
> 참조형 데이터의 프로퍼티를 재할당할 경우 객체의 변수 영역이 가리키는 데이터 영역 또한 변화하므로, 변수 영역 값이 바뀜. -> 참조형 데이터의 프로퍼티는 자유롭게 변형가능.

### 🔹 1-6
> 특정객체의 프로퍼티로 객체가 있다면? 중첩 참조가 발생. 

### 🔹 1-7
> 두 변수에 복사가 일어났다면 두 변수는 같은 데이터 영역을 가리킨다는 것을 확인할 수 있다. obj2 = obj1은 주소 복사. 같은 객체 참조.

### 🔹 1-8
> 복사된 객체의 프로퍼티를 변경하더라도? 변수가 가리키는 데이터 영역은 원본 객체와 같다. -> 원시형 변수는 상호 영향 없음. 객체의 경우 참조를 공유하기에 함께 바뀜.

### 🔹 1-9
> 복사된 객체를 변경하면 ? 원본 객체와 별개의 데이터 영역을 가리키게 된다는 것을 확인할 수 있다. -> 참조 관계는 끊어지게 됨. 독립적인 객체가 된다!

### 🔹 1-10
> 복사된 객체의 프로퍼티만을 수정하여, 원본 객체와 사본 객체가 가리키는 데이터 영역이 같아짐에 따라 원본 객체의 프로퍼티가 달라지는 문제가 발생한다는 것을 확인할 수 있다. newUser.name 변경 시 user.name도 바뀜.

### 🔹 1-11
> 객체를 처음부터 다시 만들어 변수에 저장 -> 문제를 해결할 수 있음. user와 user2는 같은 값을 갖더라도 서로 다른 객체다. 따라서 변경된 user2.name은 user.name에 영향을 주지 않는다.

### 🔹 1-12
> 객체의 속성을 반복문으로 순회하며 새 객체에 복사하는 방식의 얕은 복사 함수이다.

### 🔹 1-13
> 예제 1-12에서 만든 copyObject() 객체 복사 함수를 이용해 객체를 복사하고, 불변성을 유지함을 확인할 수 있다.

### 🔹 1-14
> 중첩된 객체에 얕은 복사를 수행하면 객체 프로퍼티에 대해 원본의 불변성이 확보되지 않는다는 것을 확인할 수 있다. user2.name은 바뀌지만 내부 객체인 urls는 여전히 공유된다.

### 🔹 1-15
> 깊은 복사는 객체 프로퍼티의 내부까지 복사해 원본 객체의 불변성을 유지한다는 것을 확인할 수 있다. user.urls와 user2.urls는 별개 객체가 되어 독립적으로 수정된다.

### 🔹 1-16
> 참조형 데이터가 몇 단계든 완전히 새로운 구조를 만든다. 객체 프로퍼티에 대해 copyObjectDeep 함수를 재귀적으로 호출해 깊은 복사를 범용적으로 수행한다는 것을 확인할 수 있다.

### 🔹 1-17
> 예제 1-16의 깊은 복사의 결과를 확인할 수 있다. 원본과 복사본이 완전히 다른 메모리 공간을 사용한다는 것을 확인할 수 있다.

### 🔹 1-18
> 객체 -> JSON 문법 -> 깊은 복사 -> 객체로 치환한다. 이때 함수는 JSON 문법으로 변경할 수 없어 복사 과정에서 무시됨을 확인할 수 있다. 복사본에서는 함수가 사라지는 현상이 발생한다는 것을 확인할 수 있다.

### 🔹 1-19
> 세 가지 경우 undefined가 자동으로 부여됨.
> - 값을 대입하지 않은 변수에 접근하는 경우
> - 존재하지 않는 프로퍼티에 접근하는 경우
> - 함수의 반환값이 존재하지 않는 경우

### 🔹 1-20
> 배열의 undefined 요소와 비어있는 요소는 다르다는 것을 확인할 수 있다. 즉, 비어있는 슬롯과 undefined는 구분되며 배열 메서드 동작에서 차이가 발생한다.

### 🔹 1-21
> 비어있는 요소는 배열 메서드의 순회 대상에서 제외된다는 것을 확인할 수 있다.

### 🔹 1-22
> typeof null이 object를 반환하는 버그가 있으므로 어떤 변수가 null인지 판별하기 위해선 일치 연산자를 사용해야 한다는 것을 알 수 있다.

---

### 🔹 2-1
> 함수를 이용해 실행 컨텍스트를 구성해보면서 콜 스택에 실행 컨텍스트가 쌓이는 순서를 확인해본다.

### 🔹 2-2
> 원본 코드의 출력을 확인해보면서 호이스팅의 개념에 대해서 확인해본다. var x는 무시되고, x = 2만 유효하다.

### 🔹 2-3
> 매개변수를 변수선언과 할당과 동일하다고 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

### 🔹 2-4
> 호이스팅을 마친 상태로 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

### 🔹 2-5
> 원본코드의 출력을 예상하고 확인하면서 호이스팅의 개념을 복습. 변수 b와 함수 b()가 같이 있을 때, 함수 선언이 우선 적용된다.

### 🔹 2-6
> 호이스팅의 개념에 대해서 확인. 결과는 동일하다. var b; 선언은 호이스팅되지만 초기화는 위치에 남고, function b(){}는 전체가 끌어올려진다.

### 🔹 2-7
> 함수 선언문(정의부만 존재)을 함수 표현식(function을 별도 변수에 할당)으로 바꾼 코드의 결과를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

### 🔹 2-8
> 함수 선언문과 익명 함수 표현식, 기명 함수표현식으로 정의된 세가지 방식을 확인하고, 예상대로 기명 함수인 d()는 외부에서 접근할 수 없어 오류를 일으키는 것을 확인해본다.

### 🔹 2-9
> 원본 코드의 출력을 확인해보면서 함수 선언문과 함수 표현식의 차이를 이해한다. sum은 정상적으로 3이 출력되나, 값이 할당되지않은 multiply는 에러 메시지가 출력된다.

### 🔹 2-10
> multiply는 선언만 호이스팅되고, 할당 전에는 undefined 상태이므로 호출 시 에러가 난다.

### 🔹 2-11
> 같은 이름의 함수가 함수 선언문으로 추가되었을 때, 실제로 호출되는 함수는 마지막에 할당한 함수이다. 즉 코드의 앞부분에서 숫자를 반환하는 코드를 짰어도 문자열을 반환하는 함수만이 실제로 호출 될 수 있다. sum(3,4) 호출 시점에서는 아직 첫 번째 선언이 유효해 숫자 합을 반환한다.

### 🔹 2-12
> 함수 표현식으로 선언한다면, 만에 하나 전역공간에 같은 이름의 함수가 있어도, 예제 2-11과는 달리 에러메세지를 출력하여 현 코드에 문제가 있다는 사실을 바로 알 수 있다.

### 🔹 2-13
> 식별자 a에 접근하려고하지만, 활성화된 inner 컨텍스트의 environmentRecord 에서의 a는 undefined 상태이기에 undefined가 출력되고, 전역 lexicalEnvironment의 a값인 1과 전역 컨텍스트의 environmentRecord의 a값인 1이 출력된다.

### 🔹 2-14
> console.dir(inner)? 콘솔로 시각화. inner 함수가 어느 스코프에서 정의되었는지를 확인할 수 있음.

### 🔹 2-15
> inner 함수 내부에서 b변수를 호출하면 스코프에 b도 노출되는 것을 확인할 수 있다.

### 🔹 2-16
> debugger로 바꾸어 크롬 브라우저에서 스코프체인과 this 정보를 확인할 수 있다.

---

### 🔹 3-1
> this와 window가 브라우저 환경에서 같은 전역 객체를 참조함을 확인할 수 있다.

### 🔹 3-2
> Node.js 환경에서 this 와 global 이 같은 전역 객체를 참조함을 확인할 수 있다. 즉, 브라우저의 window와 동일한 역할을 하는 객체가 global이다.

### 🔹 3-3
> 브라우저 환경에서 선언된 변수 a가 전역 객체 window 와 this에 속해있음을 확인할 수 있다. a, window.a, this.a는 동일한 값을 가진다.

### 🔹 3-4
> 브라우저 환경에서 window와 this의 프로퍼티로 변수 a와 b가 접근 및 수정 가능함을 확인. var로 선언된 전역 변수와 직접 window에 할당한 변수는 동일하게 전역 객체에 등록된다.

### 🔹 3-5
> 브라우저 환경에서 var로 선언된 전역 변수는 delete로 삭제할 수 없으나, 직접 window 객체에 할당된 프로퍼티는 삭제할 수 있음을 확인할 수 있다.

### 🔹 3-6
> 함수가 일반적으로 호출될 때는 전역 객체를 this로 참조하고, 객체의 메소드로 호출될 때는 해당 객체를 this로 참조함을 확인할 수 있다.

### 🔹 3-7
> 객체 내부에서 메소드가 직접 호출되거나 대괄호 표기법으로 호출될 때, this는 해당 객체를 참조함을 확인할 수 있다

### 🔹 3-8
> 객체의 메소드가 직접 호출되거나 대괄호 표기법으로 호출될 때, this는 메소드가 정의된 현재 객체를 참조함을 확인할 수 있다.

### 🔹 3-9
> 함수 내에서 정의된 내부 함수는 기본적으로 전역 객체를 this로 참조하지만, 다른 객체에 할당되어 메소드로 호출될 경우 그 객체를 this로 참조하게 된다.

### 🔹 3-10
> 객체 메소드에서 일반 함수로 호출된 내부 함수는 전역 객체를 this로 참조하며, self 변수를 사용하여 내부 함수에서 외부 함수의 this를 참조할 수 있음을 확인할 수 있다.

### 🔹 3-11
> 객체의 메소드에서 화살표 함수로 정의된 내부 함수는 외부 함수와 같은 this 즉, 호출한 객체를 참조함을 확인할 수 있다.

### 🔹 3-12
> 브라우저 환경에서 setTimeout과 배열의 forEach 메소드 내의 일반 함수는 전역 객체 window를 this로 참조하며, 이벤트 핸들러 함수에서는 해당 핸들러가 부착된 요소를 this로 참조함을 확인할 수 있다.

### 🔹 3-13
> 생성자 함수 Cat을 사용하여 choco와 nabi 두 객체를 생성하고, 각 객체는 고유의 이름과 나이 속성을 가지며 공통적으로 '야옹'을 출력함을 확인할 수 있다.

### 🔹 3-14
> 일반적으로 호출된 함수는 전역 객체를 this로 참조하며, call 메소드를 사용하여 호출된 함수는 지정된 객체 { x: 1 }를 this로 참조하고 인자를 순서대로 전달받음을 확인할 수 있다.

### 🔹 3-15
> 객체의 메소드가 직접 호출될 때는 해당 객체의 프로퍼티 a를 참조하며, call 메소드를 사용하여 다른 객체로 this를 지정할 경우 지정된 객체의 프로퍼티 a와 주어진 인자들을 사용함을 확인할 수 있다.

### 🔹 3-16
> apply 메소드를 사용하여 함수나 메소드를 호출할 때, 첫 번째 인자로 전달한 객체가 this로 설정되며, 두 번째 인자로 전달한 배열은 함수나 메소드의 매개변수로 전달됨을 확인할 수 있다.

### 🔹 3-17
> 객체에 push 메소드를 호출하여 배열처럼 동작하도록 설정하고, 이후 slice 메소드를 사용하여 객체를 배열로 변환함을 확인할 수 있다

### 🔹 3-18
> 함수 a는 가변 인자를 배열로 변환하여 각 인자를 출력하고, DOM 요소들을 선택하여 배열로 변환한 후 각 요소를 출력함을 확인할 수 있다.

### 🔹 3-19
> 문자열을 배열 메소드를 사용하여 조작할 때, push 메소드는 길이를 변경할 수 없는 읽기 전용 속성에 할당할 수 없다는 오류가 발생하며, concat 메소드는 새로운 배열을 반환하고, every 메소드는 문자열 전체가 주어진 조건을 만족하지 않음을 확인했으며, some 메소드는 문자열 중 일부가 주어진 조건을 만족함을 확인할 수 있다. map 메소드는 각 문자에 대해 '!'를 추가한 새로운 배열을 반환하고, reduce 메소드는 문자열을 누적하여 새로운 문자열을 생성함을 확인할 수 있다.

### 🔹 3-20
> 객체를 배열로 변환할 때 Array.from 메소드를 사용하여 각 프로퍼티 값을 배열 요소로 가져왔음을 확인할 수 있다.

### 🔹 3-21
> Student와 Employee 생성자 내에서 Person 생성자를 호출할 때 call 및 apply 메서드를 활용한다. 이를 통해 Person의 프로퍼티와 메서드를 상속받고, 각각의 객체에 새로운 속성을 추가한다. 최종적으로 Student와 Employee 객체를 생성함을 확인할 수 있다.

### 🔹 3-22
> 주어진 배열에서 최댓값과 최솟값을 찾아 출력함을 확인할 수 있다.

### 🔹 3-23
> 주어진 배열에서 가장 큰 수와 가장 작은 수를 각각 찾아내어 출력함을 확인할 수 있다. Math 객체의 max 및 min 메서드를 사용하여 각각 최댓값과 최솟값을 이전보다 쉽게 구할 수 있었다.

### 🔹 3-24
> 주어진 배열에서 가장 큰 수와 가장 작은 수를 각각 찾아내어 출력함을 확인할 수 있다. 펼치기 구문을 사용하여 Math 객체의 max 및 min 메서드를 간결하게 적용했다.

### 🔹 3-25
> 함수 func를 생성한 후, bind 메소드를 사용하여 다른 객체와 바인딩된 새로운 함수를 생성하고 호출했다. bind 메소드를 사용하여 함수에 추가적으로 인자를 전달하면 해당 인자가 바인딩된 함수의 매개변수로 사용된다.

### 🔹 3-26
> bind 메소드로 생성된 새로운 함수의 name 속성은 원본 함수의 이름을 유지한다.

### 🔹 3-27
> 객체의 메소드 내에서 내부 함수를 호출할 때, call 메소드를 사용하여 외부 함수의 this를 전달하거나, 내부 함수를 생성할 때 bind 메소드를 사용하여 외부 함수의 this를 유지함을 확인할 수 있다.

### 🔹 3-28
> setTimeout 함수 내에서 메소드를 호출할 때, 바로 호출한 경우와 bind 메소드를 사용하여 호출한 경우에는 this의 참조가 다르게 되어 결과가 달라짐을 확인할 수 있다.

### 🔹 3-29
> 화살표 함수 내에서 this는 상위 스코프의 this를 유지함을 확인할 수 있다. 객체의 메소드에서 화살표 함수를 사용하면 메소드가 호출된 객체를 this로 참조한다.

### 🔹 3-30
> 메소드 add를 사용하여 sum과 count를 업데이트하고, average 메소드를 사용하여 sum을 count로 나눈 평균을 계산함을 확인할 수 있다.

### 🔹 3-31
> 여러 메소드에서 자주 사용되는 배열 및 집합과 관련된 메소드들이다. 이 메소드들은 배열 또는 집합을 순회하거나 조작할 때 유용하게 사용된다. 메소드 호출 시 각각의 메소드가 받는 매개변수와 동작에 대한 설명이 포함되어 있다. 각 메소드는 주어진 콜백 함수를 배열 또는 집합의 각 요소에 적용하며, 선택적으로 콜백 함수 내에서 사용될 this 값도 지정할 수 있다.
---
## HW2: 클로저, 비동기, this, 커링 등 함수 실행 맥락과 제어 흐름
### 🔹 4-1
> setInterval 함수에 익명 함수와 숫자를 인자로 전달하여, 지정된 주기마다 익명 함수가 반복적으로 실행되도록 구성하였다.

### 🔹 4-2
> 4-1에서 사용한 익명 함수를 cbFunc라는 이름으로 명시적으로 선언하고 setInterval에 전달함으로써 함수 재사용 가능성을 높였다.

### 🔹 4-3
> 배열의 map 메서드 호출 시, 익명 함수를 첫 번째 인자로 전달하여 배열의 각 요소에 대해 일괄 변환 작업을 수행하였다.

### 🔹 4-4
> map 콜백 함수의 인자 순서를 jQuery 스타일로 조정하여, 인자에 대한 접근 방식을 실험하였다.

### 🔹 4-5
> 배열의 map 메서드를 직접 구현하여, 콜백 함수와 내부 배열 순회 방식에 대해 이해하였다.

### 🔹 4-6
> 제어권을 넘겨받는 코드에서 call/apply 메서드를 사용하여 첫 번째 인자로 콜백 함수 내부의 this가 될 객체를 명시적으로 바인딩하였다.

### 🔹 4-7
> 객체의 메서드를 콜백으로 전달할 경우, 일반 함수로 호출되어 this가 기대한 객체를 참조하지 않는 문제를 확인하였다.

### 🔹 4-8
> this를 다른 변수에 할당한 뒤, 이를 콜백 함수 내에서 사용하여 클로저로 만들었다.

### 🔹 4-9
> 4-8과 달리 this를 저장하지 않고 직접 사용한 경우, 콜백 내 this 바인딩이 유지되지 않아 함수 재사용에 제약이 있음을 확인하였다.

### 🔹 4-10
> 4-8에서 정의한 클로저 형태의 함수를 실행하고, 그 결과를 콜백으로 전달하여 실행 흐름을 추적하였다.

### 🔹 4-11
> bind 메서드를 사용하여 콜백 함수에 this를 영구적으로 바인딩함으로써, 불필요한 클로저 생성으로 인한 메모리 낭비 문제를 방지하였다.

### 🔹 4-12
> 비동기 작업이 중첩된 콜백 형태로 구성될 때 들여쓰기와 복잡도가 증가하는 현상인 "콜백 지옥" 구조를 직접 구현하여 문제점을 확인하였다.

### 🔹 4-13
> 4-12의 익명 콜백 함수를 모두 기명 함수로 치환하여, 중첩 구조를 완화하고 코드 가독성을 높였다.

### 🔹 4-14
> ES6의 Promise를 사용하여 비동기 작업을 순차적으로 구성하고, 동기식 코드처럼 표현함으로써 가독성을 개선하였다.

### 🔹 4-15
> 4-14에서 반복되는 then 체인을 함수로 추출하여 간결하고 재사용 가능한 구조로 재작성하였다.

### 🔹 4-16
> ES6의 Generator와 yield를 이용해 비동기 흐름을 제어하고, 코드 흐름을 동기적으로 표현하였다.

### 🔹 4-17
> async/await 구문을 도입하여, 가장 직관적인 형태의 비동기 코드 작성을 실현하였다.
---
### 🔹 5-1
> 내부 함수 inner가 외부 함수 outer의 지역 변수 a에 접근하여 그 값을 증가시키고 출력함으로써 클로저 개념을 이해하였다.

### 🔹 5-2
> outer 함수가 inner를 실행한 결과값을 반환하고, 이를 출력함으로써 클로저가 값을 유지하는 구조를 학습하였다.

### 🔹 5-3
> outer 함수가 inner 함수를 반환함으로써, 반환된 함수가 실행될 때마다 클로저를 통해 변수 상태를 유지하고 변화시킴을 확인하였다.

### 🔹 5-4
> 즉시 실행 함수 내에서 setInterval과 이벤트 리스너가 클로저를 통해 외부 변수를 지속적으로 참조하며 값을 변화시키는 구조를 구현하였다.

### 🔹 5-5
> 클로저 내부 변수를 증가시키고, 조건을 만족하면 null로 참조를 끊어 메모리 해제를 유도하는 방식으로 클로저의 관리 방식을 실습하였다.

### 🔹 5-6
> 클로저를 사용하여 각 리스트 아이템의 클릭 이벤트가 고유한 과일명을 참조하도록 구현하였다.

### 🔹 5-7
> 반복문 내에서 동일한 핸들러를 사용하는 경우 바인딩 문제가 발생할 수 있음을 실습하고, 직접 함수를 호출하여 특정 과일명을 출력하였다.

### 🔹 5-8
> bind 메서드를 사용하여 각 클릭 이벤트 핸들러가 고유의 인자를 갖도록 클로저를 명시적으로 구성하였다.

### 🔹 5-9
> 클로저를 반환하는 빌더 함수(alertFruitBuilder)를 사용하여 각 과일 이름을 캡처한 함수가 생성되도록 구성하였다.

### 🔹 5-10
> car 객체에 포함된 메서드가 this를 사용하여 객체 내부의 상태를 제어하도록 설계되었으며, 연료가 부족하면 메시지를 출력하도록 구현하였다.

### 🔹 5-11
> createCar 함수가 클로저를 통해 내부 상태(fuel, moved)를 은닉하고, 메서드만 외부에 노출하는 패턴으로 객체를 캡슐화하였다.

### 🔹 5-12
> Object.freeze를 통해 생성된 객체의 속성 변경을 방지하고, 클로저 기반 은닉과 외부 접근 제한을 동시에 적용하였다.

### 🔹 5-13
> bind 메서드를 사용하여 일부 인수를 고정하는 부분 적용(Partial Application) 방식으로 addPartial 함수를 구성하였다.

### 🔹 5-14
> 커스텀 partial 함수를 정의하여, 초기 인수와 추가 인수를 결합해 원래 함수를 실행하는 방식을 구현하였다.

### 🔹 5-15
> 자리 표시자를 사용한 부분 적용 기법을 구현하여, 전달 시점에 가변 인수의 위치를 제어할 수 있도록 하였다.

### 🔹 5-16
> 이벤트 핸들링 시 너무 잦은 호출을 방지하기 위해 debounce 함수로 실행을 지연시키고, 최종 이벤트 발생 후에만 함수가 실행되도록 구현하였다.

### 🔹 5-17
> curry3 함수를 통해 두 인자를 받는 함수를 커링 처리하여, 첫 인자를 고정하고 이후 인자를 나중에 받을 수 있도록 구성하였다.

### 🔹 5-18
> curry5 함수를 통해 다섯 개의 인자를 순차적으로 받을 수 있도록 함수를 커링 처리하였다.
---
## HW3
### 🔹 6-1
> Person 생성자 함수와 getName 메서드를 정의하여 이름 값을 속성으로 저장하고 반환하는 구조를 구현하였다.

### 🔹 6-2
> Constructor 생성자 함수에 프로토타입 메서드와 속성을 설정하고, 이 생성자로부터 인스턴스를 만들고 출력하였다.

### 🔹 6-3
> 배열 객체의 constructor 속성을 활용해 새로운 배열을 생성하고 그 결과를 확인하였다.

### 🔹 6-4
> dataTypes 배열의 각 요소에 대해 생성자를 NewConstructor로 지정한 뒤, 해당 생성자의 이름과 인스턴스 여부를 출력하였다.

### 🔹 6-5
> Person 생성자 함수를 다양한 방식으로 호출하여 인스턴스를 생성하고, 이들이 Person의 인스턴스인지 여부를 확인하였다.

### 🔹 6-6
> Person 생성자 함수와 기본 메서드를 정의한 후, 특정 인스턴스에서 해당 메서드를 재정의하여 새로운 동작을 부여하였다.

### 🔹 6-7
> 배열에 push 메서드로 값을 추가한 뒤, 해당 인덱스가 배열 고유 속성인지 hasOwnProperty로 검사하였다.

### 🔹 6-8
> 배열의 toString 메서드를 사용자 정의 함수로 재정의하여 언더스코어로 구분된 문자열을 반환하도록 만들었다.

### 🔹 6-9
> Object.prototype.getEntries 메서드를 정의하여 객체의 키-값 쌍을 배열로 반환하고, 다양한 타입에 대해 이를 실행하였다.

### 🔹 6-10
> Grade 생성자 함수는 가변 인자를 배열처럼 저장하며, 각 요소를 인덱스로 지정하고 length 속성을 정의하여 유사 배열 구조를 생성한다.

### 🔹 7-1
> Rectangle 생성자 함수를 만들고, 인스턴스의 넓이를 구하는 getArea 메서드와 정적 메서드 isRectangle을 추가하여 동작을 확인하였다.

### 🔹 7-2
> 배열처럼 작동하는 Grade 클래스를 정의하고 인스턴스를 생성하여, 인자를 인덱스에 저장하고 길이를 지정하였다.

### 🔹 7-3
> Grade 클래스 인스턴스의 length 속성을 delete로 삭제한 뒤 push를 호출하여 인스턴스 상태 변화를 확인하였다.

### 🔹 7-4
> Grade.prototype을 배열로 설정하고, 프로토타입에 초기 값을 갖는 배열 구조에서 push를 통해 값을 추가한 후 동작을 분석하였다.

### 🔹 7-5
> Rectangle과 Square 클래스를 정의하여 각각 넓이를 계산하고, 인스턴스를 통해 그 결과를 출력하였다.

### 🔹 7-6
> 직사각형과 정사각형을 생성자 함수로 구현하고, 각각 넓이를 계산하는 메서드를 구성하여 사용하였다.

### 🔹 7-7
> Rectangle을 상속받는 Square를 정의하여 생성자 내부에서 call을 이용해 부모의 초기화를 재사용하고 넓이를 계산하였다.

### 🔹 7-8
> extendClass1 유틸 함수를 통해 Rectangle을 상속한 Square 클래스를 구현하고, 생성자 호출과 메서드 오버라이딩을 수행하였다.

### 🔹 7-9
> 클로저 기반의 extendClass2를 통해 상속 구조를 만들고, 중간 브릿지 역할의 빈 함수로 프로토타입 연결을 수행하였다.

### 🔹 7-10
> Object.create를 활용해 Rectangle을 상속한 Square 클래스를 정의하고, 생성자 내부에서 call을 사용해 초기화하였다.

### 🔹 7-11
> extendClass1 함수를 정의하여 부모 클래스를 인스턴스로서 프로토타입에 연결하고, 메서드를 제거 후 자식 메서드를 추가하여 동결 처리하였다.

### 🔹 7-12
> 클로저와 브릿지 객체를 활용한 extendClass2 함수로 클래스 상속을 구현하고, 자식 클래스의 메서드를 동적으로 추가하였다.

### 🔹 7-13
> Object.create()를 사용하여 부모 프로토타입을 상속받는 extendClass3 함수를 정의하고, 자식 클래스의 기능을 설정하였다.

### 🔹 7-14
> 상속 구조를 위한 extendClass 함수에 super 메서드를 추가하여, 자식 클래스에서 부모 생성자와 메서드를 호출할 수 있도록 하였다.

### 🔹 7-15
> ES5와 ES6 방식의 클래스를 정의하고, 각각에서 정적 메서드와 인스턴스 메서드 호출 방식을 비교하였다.

### 🔹 7-16
> ES6 문법을 사용하여 Rectangle 클래스를 정의하고, Square 클래스가 이를 extends를 통해 상속받도록 구성하였다.
