![header](https://capsule-render.vercel.app/api?type=rect&color=gradient&customColorList=19&height=200&section=header&text=%EC%8B%A4%EC%8A%B5%EC%98%88%EC%A0%9C&fontSize=70&fontColor=ffffff)


## HW1: 변수, 할당, 복사, 컨텍스트, this

### ✅ 1-1
> 변수의 선언시 변수 영역에 식별자로 지정된 공간이 확보됨을 확인할 수 있다. 값 할당은 되지 않았으므로 undefined로 초기화됨.

### ✅ 1-2
> 데이터가 데이터영역에 할당되면 데이터는 변수 영역 값이 가리키고있는 주소에 저장됨을 확인할 수 있다. 두 과정을 한 줄로 표현할 수도 있음.

### ✅ 1-3
> 수, 문자열, boolean, Null, Undefined, Symbol은 불변(immutable). 변수 a에 문자열을 추가하면 새로운 문자열이 생성되고, a는 그 주소를 참조한다.

### ✅ 1-4
> 객체? 참조형 데이터. 참조형 데이터가 데이터 영역에 있다면 그 데이터가 가리키는 변수가 변함에 따라 그 값도 변화한다.

### ✅ 1-5
> 참조형 데이터의 프로퍼티를 재할당할 경우 객체의 변수 영역이 가리키는 데이터 영역 또한 변화하므로, 변수 영역 값이 바뀜. -> 참조형 데이터의 프로퍼티는 자유롭게 변형가능.

### ✅ 1-6
> 특정객체의 프로퍼티로 객체가 있다면? 중첩 참조가 발생. 

### ✅ 1-7
> 두 변수에 복사가 일어났다면 두 변수는 같은 데이터 영역을 가리킨다는 것을 확인할 수 있다. obj2 = obj1은 주소 복사. 같은 객체 참조.

### ✅ 1-8
> 복사된 객체의 프로퍼티를 변경하더라도? 변수가 가리키는 데이터 영역은 원본 객체와 같다. -> 원시형 변수는 상호 영향 없음. 객체의 경우 참조를 공유하기에 함께 바뀜.

### ✅ 1-9
> 복사된 객체를 변경하면 ? 원본 객체와 별개의 데이터 영역을 가리키게 된다는 것을 확인할 수 있다. -> 참조 관계는 끊어지게 됨. 독립적인 객체가 된다!

### ✅ 1-10
> 복사된 객체의 프로퍼티만을 수정하여, 원본 객체와 사본 객체가 가리키는 데이터 영역이 같아짐에 따라 원본 객체의 프로퍼티가 달라지는 문제가 발생한다는 것을 확인할 수 있다. newUser.name 변경 시 user.name도 바뀜.

### ✅ 1-11
> 객체를 처음부터 다시 만들어 변수에 저장 -> 문제를 해결할 수 있음. user와 user2는 같은 값을 갖더라도 서로 다른 객체다. 따라서 변경된 user2.name은 user.name에 영향을 주지 않는다.

### ✅ 1-12
> 객체의 속성을 반복문으로 순회하며 새 객체에 복사하는 방식의 얕은 복사 함수이다.

### ✅ 1-13
> 예제 1-12에서 만든 copyObject() 객체 복사 함수를 이용해 객체를 복사하고, 불변성을 유지함을 확인할 수 있다.

### ✅ 1-14
> 중첩된 객체에 얕은 복사를 수행하면 객체 프로퍼티에 대해 원본의 불변성이 확보되지 않는다는 것을 확인할 수 있다. user2.name은 바뀌지만 내부 객체인 urls는 여전히 공유된다.

### ✅ 1-15
> 깊은 복사는 객체 프로퍼티의 내부까지 복사해 원본 객체의 불변성을 유지한다는 것을 확인할 수 있다. user.urls와 user2.urls는 별개 객체가 되어 독립적으로 수정된다.

### ✅ 1-16
> 참조형 데이터가 몇 단계든 완전히 새로운 구조를 만든다. 객체 프로퍼티에 대해 copyObjectDeep 함수를 재귀적으로 호출해 깊은 복사를 범용적으로 수행한다는 것을 확인할 수 있다.

### ✅ 1-17
> 예제 1-16의 깊은 복사의 결과를 확인할 수 있다. 원본과 복사본이 완전히 다른 메모리 공간을 사용한다는 것을 확인할 수 있다.

### ✅ 1-18
> 객체 -> JSON 문법 -> 깊은 복사 -> 객체로 치환한다. 이때 함수는 JSON 문법으로 변경할 수 없어 복사 과정에서 무시됨을 확인할 수 있다. 복사본에서는 함수가 사라지는 현상이 발생한다는 것을 확인할 수 있다.

### ✅ 1-19
> 세 가지 경우 undefined가 자동으로 부여됨.
> - 값을 대입하지 않은 변수에 접근하는 경우
> - 존재하지 않는 프로퍼티에 접근하는 경우
> - 함수의 반환값이 존재하지 않는 경우

### ✅ 1-20
> 배열의 undefined 요소와 비어있는 요소는 다르다는 것을 확인할 수 있다. 즉, 비어있는 슬롯과 undefined는 구분되며 배열 메서드 동작에서 차이가 발생한다.

### ✅ 1-21
> 비어있는 요소는 배열 메서드의 순회 대상에서 제외된다는 것을 확인할 수 있다.

### ✅ 1-22
> typeof null이 object를 반환하는 버그가 있으므로 어떤 변수가 null인지 판별하기 위해선 일치 연산자를 사용해야 한다는 것을 알 수 있다.

---

